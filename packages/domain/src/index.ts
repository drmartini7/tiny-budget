import { z } from 'zod';

// --- Enums ---

export enum PeriodType {
  DAILY = 'DAILY',
  MONTHLY = 'MONTHLY',
  YEARLY = 'YEARLY',
}

export const PeriodTypeSchema = z.nativeEnum(PeriodType);

export enum OverflowPolicy {
  NONE = 'NONE',         // Resets to 0
  LIMITED = 'LIMITED',   // Carries over up to a max amount
  UNLIMITED = 'UNLIMITED' // Carries over everything
}

export const OverflowPolicySchema = z.nativeEnum(OverflowPolicy);

export enum TransactionType {
  EXPENSE = 'EXPENSE',
  INCOME = 'INCOME', // Manual addition
  CARRYOVER = 'CARRYOVER',
  RECURRING_RULE = 'RECURRING_RULE'
}

export const TransactionTypeSchema = z.nativeEnum(TransactionType);

// --- Zod Schemas & Types ---

// Person
export const PersonSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1),
  email: z.string().email().optional(),
  createdAt: z.date(),
  updatedAt: z.date(),
});
export type Person = z.infer<typeof PersonSchema>;

// Budget
export const BudgetSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1),
  ownerId: z.string().uuid(),
  currency: z.string().default('USD'),
  periodType: PeriodTypeSchema,
  overflowPolicy: OverflowPolicySchema,
  overflowLimit: z.number().optional(), // Only relevant if LIMITED
  startDate: z.date(),
  enabled: z.boolean().default(true),
  createdAt: z.date(),
  updatedAt: z.date(),
});
export type Budget = z.infer<typeof BudgetSchema>;

// Budget Period (The specific time slice, e.g., Jan 2026)
export const BudgetPeriodSchema = z.object({
  id: z.string().uuid(),
  budgetId: z.string().uuid(),
  startDate: z.date(),
  endDate: z.date(),
  status: z.enum(['OPEN', 'CLOSED']).default('OPEN'),
});
export type BudgetPeriod = z.infer<typeof BudgetPeriodSchema>;

// Transaction
export const TransactionSchema = z.object({
  id: z.string().uuid(),
  budgetId: z.string().uuid(),
  periodId: z.string().uuid().optional(), // Linked to a specific period
  amount: z.number(), // Negative for expenses, positive for income
  date: z.date(),
  description: z.string(),
  merchant: z.string().optional(),
  type: TransactionTypeSchema,
  sourceRuleId: z.string().uuid().optional(), // If generated by a rule
  createdAt: z.date(),
});
export type Transaction = z.infer<typeof TransactionSchema>;

// Recurring Rule
export const RuleSchema = z.object({
  id: z.string().uuid(),
  budgetId: z.string().uuid(),
  amount: z.number().positive(), // Always adds money? Or can we have recurring expenses? Assuming income for now based on "adding money"
  frequency: PeriodTypeSchema,
  executionDay: z.number().min(1).max(31), // e.g., 5th of the month
  startDate: z.date(),
  endDate: z.date().optional(),
  description: z.string(),
  lastExecutedAt: z.date().optional(),
});
export type Rule = z.infer<typeof RuleSchema>;

// Create/Update DTOs (omitting system fields)
export const CreateBudgetSchema = BudgetSchema.omit({ id: true, createdAt: true, updatedAt: true }).extend({
  initialValue: z.number().optional(),
  autoAddInPeriod: z.boolean().optional(),
  autoAddAmount: z.number().optional(),
});
export type CreateBudgetDto = z.infer<typeof CreateBudgetSchema>;

export const UpdateBudgetSchema = BudgetSchema.omit({ id: true, createdAt: true, updatedAt: true }).partial();
export type UpdateBudgetDto = z.infer<typeof UpdateBudgetSchema>;

export const TransferFundsSchema = z.object({
  fromBudgetId: z.string().uuid(),
  toBudgetId: z.string().uuid(),
  amount: z.number().positive(),
  description: z.string().optional(),
  date: z.date().optional(),
});
export type TransferFundsDto = z.infer<typeof TransferFundsSchema>;

export const CreateTransactionSchema = TransactionSchema.omit({ id: true, createdAt: true, periodId: true }).extend({
  installments: z.number().min(1).optional(),
});
export type CreateTransactionDto = z.infer<typeof CreateTransactionSchema>;

export const CreatePersonSchema = PersonSchema.omit({ id: true, createdAt: true, updatedAt: true });
export type CreatePersonDto = z.infer<typeof CreatePersonSchema>;

export const CreateRuleSchema = RuleSchema.omit({ id: true, lastExecutedAt: true });
export type CreateRuleDto = z.infer<typeof CreateRuleSchema>;

export const UpdateRuleSchema = RuleSchema.omit({ id: true, lastExecutedAt: true }).partial();
export type UpdateRuleDto = z.infer<typeof UpdateRuleSchema>;

// Utility types for API responses
export interface BudgetWithDetails extends Budget {
  owner: Person;
  currentPeriod?: BudgetPeriod;
  currentBalance: number;
}

export interface TransactionWithDetails extends Transaction {
  budget: Budget;
  period?: BudgetPeriod;
  rule?: Rule;
}

// Balance calculation result
export interface BalanceCalculation {
  openingBalance: number;
  carryover: number;
  recurringAdditions: number;
  manualAdditions: number;
  expenses: number;
  currentBalance: number;
}

// Period execution result for rules
export interface RuleExecutionResult {
  ruleId: string;
  periodId: string;
  transactionId: string;
  amount: number;
  executedAt: Date;
}

// Overflow calculation result
export interface OverflowCalculation {
  carryoverAmount: number;
  discardedAmount: number;
  overflowPolicy: OverflowPolicy;
  overflowLimit?: number;
}
